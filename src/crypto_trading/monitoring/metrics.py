"""
Metrics collection and monitoring for the trading system.
"""
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, field
import time
import logging
from datetime import datetime
from enum import Enum
from collections import defaultdict, deque

from prometheus_client import (
    Counter, Gauge, Histogram, Summary, start_http_server, generate_latest, REGISTRY
)

logger = logging.getLogger(__name__)

class MetricType(Enum):
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    SUMMARY = "summary"

@dataclass
class MetricDefinition:
    name: str
    type: MetricType
    description: str = ""
    labels: List[str] = field(default_factory=list)
    buckets: Optional[Tuple[float]] = None

class MetricsCollector:
    """
    A metrics collector that provides a unified interface for recording metrics
    and can export them in Prometheus format.
    """
    
    # Define all metrics
    METRICS = [
        # Trading metrics
        MetricDefinition("trades_total", MetricType.COUNTER, "Total number of trades", ["symbol", "side"]),
        MetricDefinition("trade_amount", MetricType.COUNTER, "Total trade amount", ["symbol", "side"]),
        MetricDefinition("trade_pnl", MetricType.GAUGE, "Profit and loss per trade", ["symbol"]),
        MetricDefinition("position_size", MetricType.GAUGE, "Current position size", ["symbol"]),
        
        # Strategy metrics
        MetricDefinition("strategy_signals", MetricType.COUNTER, "Number of signals generated by strategy", ["strategy", "signal_type"]),
        MetricDefinition("strategy_confidence", MetricType.GAUGE, "Confidence level of strategy signals", ["strategy"]),
        
        # Risk metrics
        MetricDefinition("risk_drawdown", MetricType.GAUGE, "Current drawdown percentage"),
        MetricDefinition("risk_position_risk", MetricType.GAUGE, "Risk per position as percentage of equity", ["symbol"]),
        MetricDefinition("risk_daily_pnl", MetricType.GAUGE, "Daily profit and loss"),
        
        # Performance metrics
        MetricDefinition("latency_strategy_ms", MetricType.HISTOGRAM, 
                        "Strategy processing latency in milliseconds", 
                        buckets=(1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000)),
        
        # System metrics
        MetricDefinition("system_memory_usage", MetricType.GAUGE, "Memory usage in bytes"),
        MetricDefinition("system_cpu_usage", MetricType.GAUGE, "CPU usage percentage"),
        
        # Exchange metrics
        MetricDefinition("exchange_errors", MetricType.COUNTER, "Number of exchange API errors", ["exchange", "error_type"]),
        MetricDefinition("exchange_rate_limit_remaining", MetricType.GAUGE, "Remaining API rate limit", ["exchange", "endpoint"]),
        
        # WebSocket metrics
        MetricDefinition("websocket_messages_received", MetricType.COUNTER, "Number of WebSocket messages received", ["exchange"]),
        MetricDefinition("websocket_reconnects", MetricType.COUNTER, "Number of WebSocket reconnection attempts", ["exchange"]),
        
        # Order book metrics
        MetricDefinition("order_book_depth", MetricType.GAUGE, "Order book depth at different price levels", 
                        ["symbol", "side"], buckets=(1, 5, 10, 25, 50, 100, 250, 500, 1000)),
    ]
    
    def __init__(self, prometheus_port: int = 8000):
        """
        Initialize the metrics collector.
        
        Args:
            prometheus_port: Port to expose Prometheus metrics on
        """
        self.prometheus_port = prometheus_port
        self.metrics = {}
        self._init_metrics()
        
    def _init_metrics(self) -> None:
        """Initialize all metrics."""
        for metric_def in self.METRICS:
            if metric_def.type == MetricType.COUNTER:
                self.metrics[metric_def.name] = Counter(
                    metric_def.name,
                    metric_def.description,
                    metric_def.labels
                )
            elif metric_def.type == MetricType.GAUGE:
                self.metrics[metric_def.name] = Gauge(
                    metric_def.name,
                    metric_def.description,
                    metric_def.labels
                )
            elif metric_def.type == MetricType.HISTOGRAM:
                self.metrics[metric_def.name] = Histogram(
                    metric_def.name,
                    metric_def.description,
                    metric_def.labels,
                    buckets=metric_def.buckets or Histogram.DEFAULT_BUCKETS
                )
            elif metric_def.type == MetricType.SUMMARY:
                self.metrics[metric_def.name] = Summary(
                    metric_def.name,
                    metric_def.description,
                    metric_def.labels
                )
    
    def start_http_server(self) -> None:
        """Start the Prometheus metrics HTTP server."""
        try:
            start_http_server(self.prometheus_port)
            logger.info(f"Prometheus metrics server started on port {self.prometheus_port}")
        except Exception as e:
            logger.error(f"Failed to start Prometheus metrics server: {e}")
    
    def record_trade(
        self, 
        symbol: str, 
        side: str, 
        amount: float, 
        price: float,
        pnl: Optional[float] = None
    ) -> None:
        """
        Record a trade.
        
        Args:
            symbol: Trading pair symbol
            side: 'buy' or 'sell'
            amount: Trade amount
            price: Trade price
            pnl: Profit and loss from the trade (if available)
        """
        try:
            self.metrics["trades_total"].labels(symbol=symbol, side=side).inc()
            self.metrics["trade_amount"].labels(symbol=symbol, side=side).inc(amount * price)
            
            if pnl is not None:
                self.metrics["trade_pnl"].labels(symbol=symbol).set(pnl)
                
                # Update daily P&L tracking
                self.metrics["risk_daily_pnl"].inc(pnl)
                
                # Update drawdown if this is a loss
                if pnl < 0:
                    self._update_drawdown_metrics()
        except Exception as e:
            logger.error(f"Error recording trade metrics: {e}")
    
    def record_signal(
        self, 
        strategy: str, 
        signal_type: str, 
        symbol: str, 
        confidence: float = 1.0
    ) -> None:
        """
        Record a trading signal.
        
        Args:
            strategy: Name of the strategy
            signal_type: Type of signal (e.g., 'buy', 'sell')
            symbol: Trading pair symbol
            confidence: Confidence level of the signal (0-1)
        """
        try:
            self.metrics["strategy_signals"].labels(
                strategy=strategy, 
                signal_type=signal_type
            ).inc()
            
            self.metrics["strategy_confidence"].labels(
                strategy=strategy
            ).set(confidence)
        except Exception as e:
            logger.error(f"Error recording signal metrics: {e}")
    
    def update_position(
        self, 
        symbol: str, 
        size: float, 
        entry_price: float,
        current_price: float,
        equity: float
    ) -> None:
        """
        Update position metrics.
        
        Args:
            symbol: Trading pair symbol
            size: Position size (positive for long, negative for short)
            entry_price: Entry price of the position
            current_price: Current market price
            equity: Current account equity
        """
        try:
            # Update position size
            self.metrics["position_size"].labels(symbol=symbol).set(size)
            
            # Calculate and update position risk
            if equity > 0:
                position_value = abs(size) * current_price
                risk_percent = (position_value / equity) * 100
                self.metrics["risk_position_risk"].labels(symbol=symbol).set(risk_percent)
        except Exception as e:
            logger.error(f"Error updating position metrics: {e}")
    
    def record_exchange_error(
        self, 
        exchange: str, 
        error_type: str,
        endpoint: Optional[str] = None
    ) -> None:
        """
        Record an exchange API error.
        
        Args:
            exchange: Exchange name (e.g., 'binance', 'bitfinex')
            error_type: Type of error (e.g., 'rate_limit', 'timeout', 'api_error')
            endpoint: API endpoint that generated the error (if applicable)
        """
        try:
            self.metrics["exchange_errors"].labels(
                exchange=exchange,
                error_type=error_type
            ).inc()
        except Exception as e:
            logger.error(f"Error recording exchange error: {e}")
    
    def update_rate_limit(
        self, 
        exchange: str, 
        endpoint: str, 
        remaining: int,
        limit: Optional[int] = None
    ) -> None:
        """
        Update rate limit information.
        
        Args:
            exchange: Exchange name
            endpoint: API endpoint
            remaining: Remaining requests in the current window
            limit: Total request limit (if available)
        """
        try:
            # Record remaining requests
            self.metrics["exchange_rate_limit_remaining"].labels(
                exchange=exchange,
                endpoint=endpoint
            ).set(remaining)
            
            # Optionally, you could add a metric for the limit itself
            # and calculate the usage percentage
        except Exception as e:
            logger.error(f"Error updating rate limit metrics: {e}")
    
    def record_websocket_message(self, exchange: str) -> None:
        """
        Record a WebSocket message received from an exchange.
        
        Args:
            exchange: Exchange name
        """
        try:
            self.metrics["websocket_messages_received"].labels(
                exchange=exchange
            ).inc()
        except Exception as e:
            logger.error(f"Error recording WebSocket message: {e}")
    
    def record_websocket_reconnect(self, exchange: str) -> None:
        """
        Record a WebSocket reconnection attempt.
        
        Args:
            exchange: Exchange name
        """
        try:
            self.metrics["websocket_reconnects"].labels(
                exchange=exchange
            ).inc()
        except Exception as e:
            logger.error(f"Error recording WebSocket reconnect: {e}")
    
    def record_order_book_depth(
        self, 
        symbol: str, 
        side: str, 
        depth: int,
        price_levels: int = 10
    ) -> None:
        """
        Record order book depth metrics.
        
        Args:
            symbol: Trading pair symbol
            side: 'bid' or 'ask'
            depth: Number of price levels to consider
            price_levels: Total number of price levels available
        """
        try:
            self.metrics["order_book_depth"].labels(
                symbol=symbol,
                side=side
            ).observe(min(depth, price_levels))
        except Exception as e:
            logger.error(f"Error recording order book depth: {e}")
    
    def record_latency(self, component: str, latency_ms: float) -> None:
        """
        Record latency for a component.
        
        Args:
            component: Component name (e.g., 'strategy', 'exchange')
            latency_ms: Latency in milliseconds
        """
        try:
            if component == "strategy":
                self.metrics["latency_strategy_ms"].observe(latency_ms)
            # Add more components as needed
        except Exception as e:
            logger.error(f"Error recording latency metric: {e}")
    
    def _update_drawdown_metrics(self) -> None:
        """Update drawdown metrics based on current equity."""
        # This is a simplified example - you'd want to track peak equity over time
        # to calculate the actual drawdown
        try:
            # Get current equity from the equity metric
            current_equity = self.metrics["risk_daily_pnl"]._value.get()
            
            # This is a placeholder - in a real implementation, you'd track peak equity
            peak_equity = max(self.metrics["risk_daily_pnl"]._value.get(), 1)
            
            # Calculate drawdown percentage
            drawdown_pct = ((peak_equity - current_equity) / peak_equity) * 100
            
            self.metrics["risk_drawdown"].set(max(0, drawdown_pct))
        except Exception as e:
            logger.error(f"Error updating drawdown metrics: {e}")
    
    def get_metrics(self) -> Dict[str, Any]:
        """
        Get all current metrics as a dictionary.
        
        Returns:
            Dictionary containing all metrics
        """
        metrics = {}
        for name, metric in self.metrics.items():
            try:
                if hasattr(metric, '_metrics'):
                    # For metrics with labels
                    metrics[name] = {
                        str(labels): value for labels, value in metric._metrics.items()
                    }
                else:
                    # For metrics without labels
                    metrics[name] = metric._value.get()
            except Exception as e:
                logger.error(f"Error getting metric {name}: {e}")
        return metrics
    
    def generate_prometheus_metrics(self) -> bytes:
        """
        Generate Prometheus metrics in text format.
        
        Returns:
            bytes: Prometheus metrics in text format
        """
        return generate_latest(REGISTRY)

# Singleton instance
metrics = MetricsCollector()

def start_metrics_server(port: int = 8000) -> None:
    """
    Start the metrics HTTP server.
    
    Args:
        port: Port to expose metrics on
    """
    global metrics
    metrics = MetricsCollector(port)
    metrics.start_http_server()
