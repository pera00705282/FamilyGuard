""\nIn-Memory Caching Module\n\nThis module provides a high-performance in-memory caching system with\ntime-based expiration, size limits, and automatic eviction policies.\n"""\nfrom __future__ import annotations\n\nimport time\nimport threading\nfrom collections import OrderedDict\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum, auto\nfrom typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union\nimport hashlib\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\nclass EvictionPolicy(Enum):\n    """Cache eviction policies"""\n    LRU = auto()  # Least Recently Used\n    LFU = auto()  # Least Frequently Used\n    FIFO = auto()  # First In, First Out\n    LIFO = auto()  # Last In, First Out\n\n@dataclass\nclass CacheEntry(Generic[T]):\n    """Represents a single cache entry"""\n    value: T\n    created_at: float\n    last_accessed: float\n    access_count: int = 1\n    expires_at: Optional[float] = None\n    tags: List[str] = field(default_factory=list)\n\nclass Cache(Generic[T]):\n    """\n    A high-performance, thread-safe in-memory cache with time-based expiration\n    and configurable eviction policies.\n    """\n    \n    def __init__(\n        self,\n        max_size: int = 1000,\n        default_ttl: Optional[float] = 300.0,  # 5 minutes\n        eviction_policy: EvictionPolicy = EvictionPolicy.LRU,\n        namespace: str = "default"\n    ):\n        """\n        Initialize the cache.\n        \n        Args:\n            max_size: Maximum number of items to store in the cache\n            default_ttl: Default time-to-live in seconds for cache entries (None = no expiration)\n            eviction_policy: Policy to use when evicting items from the cache\n            namespace: Namespace for this cache instance (useful for debugging and metrics)\n        """\n        self.max_size = max_size\n        self.default_ttl = default_ttl\n        self.eviction_policy = eviction_policy\n        self.namespace = namespace\n        \n        # Use OrderedDict for O(1) get/set/delete operations\n        self._cache: Dict[str, CacheEntry[T]] = OrderedDict()\n        self._lock = threading.RLock()\n        self._hits = 0\n        self._misses = 0\n        self._evictions = 0\n        self._total_size = 0\n        \n        # For LFU policy\n        self._frequency: Dict[str, int] = {}\n        \n        logger.info(\n            f"Initialized cache '{namespace}' with max_size={max_size}, "\n            f"default_ttl={default_ttl}, policy={eviction_policy.name}"\n        )\n    \n    def __contains__(self, key: str) -> bool:\n        """Check if a key exists in the cache"""\n        return self.has(key)\n    \n    def __getitem__(self, key: str) -> T:\n        """Get an item from the cache"""\n        return self.get(key)\n    \n    def __setitem__(self, key: str, value: T) -> None:\n        """Set an item in the cache with default TTL"""\n        self.set(key, value)\n    \n    def __delitem__(self, key: str) -> None:\n        """Delete an item from the cache"""\n        self.delete(key)\n    \n    def __len__(self) -> int:\n        """Get the number of items in the cache"""\n        with self._lock:\n            return len(self._cache)\n    \n    def __repr__(self) -> str:\n        """String representation of the cache"""\n        return (\n            f"<Cache namespace='{self.namespace}' size={len(self)}/"\n            f"{self.max_size} hits={self._hits} misses={self._misses} "\n            f"evictions={self._evictions}>"\n        )\n    \n    def set(\n        self,\n        key: str,\n        value: T,\n        ttl: Optional[float] = None,\n        tags: Optional[List[str]] = None\n    ) -> None:\n        """\n        Add an item to the cache.\n        \n        Args:\n            key: Cache key\n            value: Value to cache\n            ttl: Time-to-live in seconds (None = use default, 0 = no expiration)\n            tags: Optional list of tags for this cache entry\n        """\n        if ttl is None:\n            ttl = self.default_ttl\n        \n        with self._lock:\n            # Evict if we're at capacity\n            if len(self._cache) >= self.max_size:\n                self._evict()\n            \n            now = time.time()\n            expires_at = now + ttl if ttl > 0 else None\n            \n            # Create or update the cache entry\n            if key in self._cache:\n                # Update existing entry\n                self._cache[key].value = value\n                self._cache[key].last_accessed = now\n                self._cache[key].access_count += 1\n                self._cache[key].expires_at = expires_at\n                if tags is not None:\n                    self._cache[key].tags = tags\n                \n                # Move to end for LRU/LIFO\n                if self.eviction_policy in (EvictionPolicy.LRU, EvictionPolicy.LIFO):\n                    self._cache.move_to_end(key)\n            else:\n                # Add new entry\n                self._cache[key] = CacheEntry(\n                    value=value,\n                    created_at=now,\n                    last_accessed=now,\n                    expires_at=expires_at,\n                    tags=tags or []\n                )\n                # For FIFO/LIFO, we need to ensure the order is maintained\n                if self.eviction_policy == EvictionPolicy.FIFO:\n                    self._cache.move_to_end(key, last=False)\n    \n    def get(\n        self,\n        key: str,\n        default: Any = None,\n        update_ttl: bool = False\n    ) -> Union[T, Any]:\n        """\n        Get an item from the cache.\n        \n        Args:\n            key: Cache key\n            default: Default value to return if key is not found\n            update_ttl: If True, reset the TTL for this item\n            \n        Returns:\n            The cached value or default if not found/expired\n        """\n        with self._lock:\n            if key not in self._cache:\n                self._misses += 1\n                return default\n            \n            entry = self._cache[key]\n            now = time.time()\n            \n            # Check if the entry has expired\n            if entry.expires_at is not None and now > entry.expires_at:\n                del self._cache[key]\n                self._misses += 1\n                return default\n            \n            # Update access metadata\n            entry.last_accessed = now\n            entry.access_count += 1\n            \n            # Update TTL if requested\n            if update_ttl and self.default_ttl is not None:\n                entry.expires_at = now + self.default_ttl\n            \n            # Update order based on eviction policy\n            if self.eviction_policy == EvictionPolicy.LRU:\n                self._cache.move_to_end(key)\n            elif self.eviction_policy == EvictionPolicy.LFU:\n                self._frequency[key] = self._frequency.get(key, 0) + 1\n            \n            self._hits += 1\n            return entry.value\n    \n    def get_or_set(\n        self,\n        key: str,\n        default_value: Union[T, Callable[[], T]],\n        ttl: Optional[float] = None,\n        tags: Optional[List[str]] = None\n    ) -> T:\n        """\n        Get a value from the cache, or set it if it doesn't exist.\n        \n        Args:\n            key: Cache key\n            default_value: Default value or callable that returns the default value\n            ttl: Time-to-live in seconds (None = use default, 0 = no expiration)\n            tags: Optional list of tags for this cache entry\n            \n        Returns:\n            The cached or newly set value\n        """\n        value = self.get(key)\n        if value is not None:\n            return value\n        \n        # If we get here, the key doesn't exist or has expired\n        if callable(default_value):\n            value = default_value()\n        else:\n            value = default_value\n            \n        self.set(key, value, ttl=ttl, tags=tags)\n        return value\n    \n    def delete(self, key: str) -> bool:\n        """\n        Delete an item from the cache.\n        \n        Returns:\n            True if the item was deleted, False if it didn't exist\n        """\n        with self._lock:\n            if key in self._cache:\n                del self._cache[key]\n                if key in self._frequency:\n                    del self._frequency[key]\n                return True\n            return False\n    \n    def clear(self) -> None:\n        """Clear all items from the cache"""\n        with self._lock:\n            self._cache.clear()\n            self._frequency.clear()\n    \n    def has(self, key: str) -> bool:\n        """Check if a key exists in the cache and is not expired"""\n        with self._lock:\n            if key not in self._cache:\n                return False\n                \n            entry = self._cache[key]\n            if entry.expires_at is not None and time.time() > entry.expires_at:\n                del self._cache[key]\n                return False\n                \n            return True\n    \n    def ttl(self, key: str) -> Optional[float]:\n        """\n        Get the remaining time-to-live for a key.\n        \n        Returns:\n            Remaining TTL in seconds, or None if the key doesn't exist or has no TTL\n        """\n        with self._lock:\n            if key not in self._cache:\n                return None\n                \n            entry = self._cache[key]\n            if entry.expires_at is None:\n                return None\n                \n            remaining = entry.expires_at - time.time()\n            return max(0, remaining) if remaining > 0 else None\n    \n    def expire(self, key: str, ttl: float) -> bool:\n        """\n        Set a new TTL for a key.\n        \n        Returns:\n            True if the TTL was updated, False if the key doesn't exist\n        """\n        with self._lock:\n            if key not in self._cache:\n                return False\n                \n            self._cache[key].expires_at = time.time() + ttl\n            return True\n    \n    def stats(self) -> Dict[str, Any]:\n        """Get cache statistics"""\n        with self._lock:\n            return {\n                'hits': self._hits,\n                'misses': self._misses,\n                'size': len(self._cache),\n                'max_size': self.max_size,\n                'evictions': self._evictions,\n                'hit_rate': self._hits / (self._hits + self._misses) if (self._hits + self._misses) > 0 else 0.0,\n                'namespace': self.namespace,\n                'eviction_policy': self.eviction_policy.name\n            }\n    \n    def keys(self) -> List[str]:\n        """Get all cache keys"""\n        with self._lock:\n            return list(self._cache.keys())\n    \n    def values(self) -> List[T]:\n        """Get all cache values"""\n        with self._lock:\n            return [entry.value for entry in self._cache.values()]\n    \n    def items(self) -> List[tuple[str, T]]:\n        """Get all cache key-value pairs"""\n        with self._lock:\n            return [(k, v.value) for k, v in self._cache.items()]\n    \n    def get_by_tag(self, tag: str) -> Dict[str, T]:\n        """Get all cache entries with the given tag"""\n        result = {}\n        with self._lock:\n            for key, entry in self._cache.items():\n                if tag in entry.tags:\n                    result[key] = entry.value\n        return result\n    \n    def delete_by_tag(self, tag: str) -> int:\n        """\n        Delete all cache entries with the given tag.\n        \n        Returns:\n            Number of entries deleted\n        """\n        count = 0\n        with self._lock:\n            keys_to_delete = [\n                key for key, entry in self._cache.items()\n                if tag in entry.tags\n            ]\n            \n            for key in keys_to_delete:\n                del self._cache[key]\n                if key in self._frequency:\n                    del self._frequency[key]\n                count += 1\n                \n        return count\n    \n    def _evict(self) -> None:\n        """Evict items from the cache based on the eviction policy"""\n        if not self._cache:\n            return\n            \n        self._evictions += 1\n        \n        if self.eviction_policy == EvictionPolicy.LRU:\n            # Remove the first item (least recently used)\n            self._cache.popitem(last=False)\n            \n        elif self.eviction_policy == EvictionPolicy.LFU:\n            # Find the least frequently used item\n            if not self._frequency:\n                # Initialize frequencies if empty\n                self._frequency = {k: 1 for k in self._cache.keys()}\n                \n            # Find the key with the minimum frequency\n            min_key = min(self._frequency.items(), key=lambda x: x[1])[0]\n            del self._cache[min_key]\n            del self._frequency[min_key]\n            \n        elif self.eviction_policy == EvictionPolicy.FIFO:\n            # Remove the first item (oldest)\n            self._cache.popitem(last=False)\n            \n        elif self.eviction_policy == EvictionPolicy.LIFO:\n            # Remove the last item (newest)\n            self._cache.popitem()\n\n# Global cache instance for simple use cases\n_default_cache = Cache(max_size=1000, namespace="global")\n\ndef get_default_cache() -> Cache:\n    """Get the default global cache instance"""\n    return _default_cache\n\ndef cache_result(\n    ttl: Optional[float] = 300.0,\n    key_func: Optional[Callable[..., str]] = None,\n    cache_instance: Optional[Cache] = None\n) -> Callable:\n    """\n    Decorator to cache function results.\n    \n    Args:\n        ttl: Time-to-live in seconds for cached results\n        key_func: Function to generate cache keys from function arguments\n        cache_instance: Cache instance to use (defaults to global cache)\n    """\n    if cache_instance is None:\n        cache_instance = _default_cache\n    \n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Generate a cache key\n            if key_func:\n                cache_key = key_func(*args, **kwargs)\n            else:\n                # Default key generation\n                key_parts = [func.__module__, func.__name__]\n                if args:\n                    key_parts.extend(str(arg) for arg in args)\n                if kwargs:\n                    key_parts.extend(f"{k}={v}" for k, v in sorted(kwargs.items()))\n                cache_key = hashlib.md5("|".join(key_parts).encode('utf-8')).hexdigest()\n            \n            # Try to get from cache\n            cached_result = cache_instance.get(cache_key)\n            if cached_result is not None:\n                return cached_result\n            \n            # Call the function and cache the result\n            result = func(*args, **kwargs)\n            cache_instance.set(cache_key, result, ttl=ttl)\n            return result\n        return wrapper\n    return decorator\n\n# Example usage\nif __name__ == "__main__":\n    # Create a cache with LRU eviction policy\n    cache = Cache(max_size=3, eviction_policy=EvictionPolicy.LRU)\n    \n    # Basic operations\n    cache.set("key1", "value1")\n    cache.set("key2", "value2", ttl=60)  # 60 seconds TTL\n    \n    # Get with default value\n    value = cache.get("key3", default="default_value")\n    print(f"Got: {value}")  # Output: Got: default_value\n    \n    # Using the decorator\n    @cache_result(ttl=300)\n    def expensive_operation(x, y):\n        print(f"Computing {x} + {y}...")\n        return x + y\n    \n    # First call computes and caches the result\n    result1 = expensive_operation(2, 3)  # Will print "Computing..."\n    # Second call returns the cached result\n    result2 = expensive_operation(2, 3)  # Will not print anything\n    print(f"Results: {result1}, {result2}")\n    \n    # Using tags\n    cache.set("user:1", {"id": 1, "name": "Alice"}, tags=["users"])\n    cache.set("user:2", {"id": 2, "name": "Bob"}, tags=["users"])\n    \n    # Get all users\n    users = cache.get_by_tag("users")\n    print(f"Users: {users}")\n    \n    # Delete all users\n    cache.delete_by_tag("users")
